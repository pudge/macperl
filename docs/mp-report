#!/usr/bin/perl -w

use lib "../perl/lib";
use strict;
use CGI;
use DBIx::Password;
use Digest::MD5 'md5_hex';
use Template;
my($constants, $dbh, $user, $form, $vu, $cgi, $template, %T, %ops);

{
	$constants->{Id}		= '$Id$';
	$constants->{virtual_user}	= "macperl";
	$constants->{cookie_name}	= "report_user";
	$constants->{cookie_path}	= "/";
	$constants->{cookie_domain}	= "macperl.sourceforge.net";
	$constants->{tt_path}		= [
					"../htdocs/templates/mp-report",
					"../htdocs/templates"
					];

	$dbh = DBIx::Password->connect($constants->{virtual_user});
	END { $dbh->disconnect if $dbh }
	$cgi = new CGI;
	$template = Template->new(
		TRIM		=> 1,
		INCLUDE_PATH	=> $constants->{tt_path}
	);
}

use constant ALLOWED	=> 0;
use constant FUNCTION	=> 1;

sub main {
	$form = $cgi->Vars;
	login();

	# possible value of "op" parameter in form
	%ops = (
		add_user	=> [ 1,			\&add_user	],
		create_user	=> [ 1,			\&create_user	],
		add_config	=> [ $user->{id},	\&add_config	],
		create_config	=> [ $user->{id},	\&create_config	],
		add_test	=> [ $user->{id},	\&add_test	],
		create_test	=> [ $user->{id},	\&create_test	],
		view_tests	=> [ 1,			\&view_tests	],
		default		=> [ 1,			\&default	]
	);

	# prepare op to proper value if bad value given
	my $op = $form->{op};
	if (!$op || !exists $ops{$op} || !$ops{$op}[ALLOWED]) {
		$op = 'default';
	}

	# dispatch of op
	$ops{$op}[FUNCTION]->();
	footer();
}

# main functions
sub view_tests {
	my $tests = get_tests();
	my $user_tests = get_usertests();

	header('View Tests');
	process('view_tests', {
		tests		=> $tests,
		user_tests	=> $user_tests,
		configs		=> get_configsdesc(),
		users		=> get_users(),
		map { ($_ => get_param($_)) }
			qw( compiler status )
	});
}

sub create_test {
	my(%test, $id, $sth);

	$test{is_tool} = $form->{is_tool} ? 1 : 0;

	for (qw(test_id config_id status compiler notes results)) {
		$test{$_} = $form->{$_};
	}

	$sth = get_sth(<<'EOT', $user->{id}, @test{qw(test_id config_id status compiler is_tool notes results)});
INSERT INTO	user_tests	(user_id, test_id, config_id, status, compiler, is_tool, notes, results)
VALUES			(?, ?, ?, ?, ?, ?, ?, ?)
EOT
	$test{id} = $sth->{'mysql_insertid'};
	my $test_id = get_testdesc();
	$test{test} = $test_id->{$test{test_id}};

	header('Create Test');
	process('create_test', { test => \%test });
}

sub create_config {
	my(%config, $id, $sth);

	if (!$form->{name}) {
		error("Configuration must have a name.  Please go back and try again.");
		return;
	}

	for (qw(cvs build mwc mpw)) {
		$config{$_} = $form->{$_} ? 1 : 0;
	}

	for (qw(processor ram version name notes results)) {
		$config{$_} = $form->{$_};
	}

	$sth = get_sth(<<'EOT', $user->{id}, @config{qw(processor ram version cvs build mwc mpw name notes results)});
INSERT INTO	configs	(user_id, processor, ram, version, cvs, build, mwc, mpw, name, notes, results)
VALUES			(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
EOT
	$config{id} = $sth->{'mysql_insertid'};

	header('Create Configuration');
	process('create_config', { config => \%config });
}

sub create_user {
	my($id, $name, $email, $pass, $sf_match, $sth);

	if (!$form->{pass1} || !$form->{pass2}) {
		error('No password given.  Please try again.');
		return;
	} elsif ($form->{pass1} ne $form->{pass2}) {
		error("Passwords do not match.  Please try again.");
		return;
	} else {
		$pass = md5_hex($form->{pass1});
	}


	($name = lc $form->{user}) =~ s/[^a-zA-Z0-9_.-]+//g;
	if (!$name) {
		error('No user name given.  Please try again.');
		return;
	} elsif (user_exists($name)) {
		error("Sorry, that user name is already in use.  Please select another.");
		return;
	}

	$email = $form->{email};
	$sf_match = $form->{sf_match} ? 1 : 0;

	$sth = get_sth(<<'EOT', $name, $email, $pass, $sf_match);
INSERT INTO	users	(user, email, pass, sf_match)
VALUES			(?, ?, ?, ?)
EOT
	$id = $sth->{'mysql_insertid'};
	$user = {
		id		=> $id,
		user		=> $name,
		email		=> $email,
		pass		=> $pass,
		sf_match	=> $sf_match,
	} if $id;

	header('Create User');
	process('create_user');
}

sub add_test {
	my $config_id = get_configdesc();
	my $test_id   = get_tests();
	if (! keys %$config_id) {
		error("Please add a configuration before entering test results.");
		return;
	}

	header('Add Test');
	process('add_test', {
		config_id	=> $config_id,
		test_id		=> $test_id,
		map { ($_ => get_param($_)) } qw( status compiler )
	});
}

sub add_config {
	header('Add Configuration');
	process('add_config', { map { ($_ => get_param($_)) }
		qw( processor version )
	});
}

sub add_user {
	header('Add User');
	process('add_user');
}

sub default {
	header();
	process('notes');
}

sub header {
	print $cgi->header(prep_cookie());
	process('header', { title => $_[0] });
}

sub footer {
	process('menu');
	process('footer');
}


# helper functions

sub login {
	my $sth;
	$user = {};

	if ($form->{op} eq 'logout') {
		return;

	} elsif ($form->{user} && $form->{pass}) {
		$sth = get_sth(<<'EOT', $form->{user}, md5_hex($form->{pass}));
SELECT	id,user,email,pass,sf_match
FROM	users
WHERE	user=? AND pass=?
EOT
		
	} else {
		my($id, $pass) = get_cookie($cgi);
		return unless $id && $pass;
		$sth = get_sth(<<'EOT', $id, $pass);
SELECT	id,user,email,pass,sf_match
FROM	users
WHERE	id=? AND pass=?
EOT
	}

	@{$user}{qw(id user email pass sf_match)} =
		$sth->fetchrow_array;
}

sub user_exists {
	my $sth = get_sth(<<'EOT', $_[0]);
SELECT	user
FROM	users
WHERE	user=?
EOT
	return $sth->fetchrow_array;
}

sub get_param {
	my($param) = @_;
	my $sth = get_sth(<<'EOT', $param);
SELECT	id,name
FROM	code_param
WHERE	type=?
EOT

	my $data = { 9999 => "Unknown" };
	while (my $row = $sth->fetchrow_arrayref) {
		$data->{$row->[0]} = $row->[1];
	}
	return $data;
}

sub get_users {
	my $sth = get_sth(<<'EOT');
SELECT		id, user, sf_match
FROM		users
EOT

	my $data = {};
	while (my $row = $sth->fetchrow_hashref) {
		$data->{$row->{id}} = $row;
	}
	return $data;
}

sub get_usertests {
	my $sth = get_sth(<<'EOT');
SELECT		id, user_id, test_id, config_id, status, compiler, is_tool, date
FROM		user_tests
ORDER BY	id
EOT

	my $data = {};
	while (my $row = $sth->fetchrow_hashref) {
		push @{$data->{$row->{test_id}}}, $row;
	}
	return $data;
}

sub get_tests {
	my $sth = get_sth(<<'EOT');
SELECT		id, test, status
FROM		tests
ORDER BY	test
EOT

	my $user_tests = get_usertests();

	my $data = [];
	while (my $row = $sth->fetchrow_hashref) {
		if (!$row->{status}) {
			my %rank;
			for my $tr (@{$user_tests->{$row->{id}}}) {
				$rank{$tr->{status}}++;
			}
			($row->{status}) = sort {
				$rank{$b} <=> $rank{$a}
					||
				    $b <=> $a
			} keys %rank;
		}
		push @$data, $row;
	}

	return $data;
}

sub get_testdesc {
	my $sth = get_sth(<<'EOT');
SELECT		id, test
FROM		tests
EOT

	my $data = {};
	while (my $row = $sth->fetchrow_arrayref) {
		$data->{$row->[0]} = $row->[1];
	}
	return $data;
}

sub get_config {
	my $sth = get_sth(<<'EOT', $user->{id});
SELECT	id, user_id, processor, ram, version, cvs, build, mwc, mpw, date, name, notes, results
FROM	configs
WHERE	user_id=?
EOT

	my $data = {};
	while (my $row = $sth->fetchrow_hashref) {
		$data->{$row->{id}} = $row;
	}
	return $data;
}

sub get_configdesc {
	my $sth = get_sth(<<'EOT', $user->{id});
SELECT	id, name
FROM	configs
WHERE	user_id=?
EOT

	my $data = {};
	while (my $row = $sth->fetchrow_arrayref) {
		$data->{$row->[0]} = $row->[1];
	}
	return $data;
}

sub get_configsdesc {
	my $sth = get_sth(<<'EOT');
SELECT	id, name
FROM	configs
EOT

	my $data = {};
	while (my $row = $sth->fetchrow_arrayref) {
		$data->{$row->[0]} = $row->[1];
	}
	return $data;
}

sub process {
	my($name, $data) = @_;

	$data = {
		env  => { map { lc, $ENV{$_} } keys %ENV },
		user => $user,
		form => $form,
		constants => $constants,
		ref $data ? %$data : ()
	};
	$template->process($name, $data);
}

sub get_sth {
	my($sql, @params) = @_;
	my $sth = $dbh->prepare($sql);
	$sth->execute(@params);
	return $sth;
}

sub error {
	my($error) = @_;
	header('Error');
	process('error', { err => $error });
}

sub get_cookie {
	my($cgi) = @_;
	my $cookie = $cgi->cookie($constants->{cookie_name});
	if ($cookie) {
		my($id, $pass) = split /:/, $cookie, 2;
		return($id, $pass);
	} else {
		return;
	}
}

sub prep_cookie {
	my($session) = @_;

	my $val = $user->{id} && $user->{pass}
		? "$user->{id}:$user->{pass}"
		: "";

	my %cookie = (
		-domain	=> $constants->{cookie_domain},
		-name   => $constants->{cookie_name},
		-path	=> $constants->{cookie_path},
		-value	=> $val
	);
	
	$cookie{-expires} = '+6M' unless $session;

	return {
		-date		=> $cgi->expires(0, 'http'),
		-set_cookie	=> $cgi->cookie(%cookie)
	};
}

main();

1;

__END__
